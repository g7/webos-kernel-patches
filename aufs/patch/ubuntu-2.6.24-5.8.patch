This patch makes aufs version 20080128 to support the ubuntu kernel only
(http://archive.ubuntu.com/ubuntu/pool/main/l/linux/linux-source-2.6.24_2.6.24-5.8_all.deb).
You may also want to try the updated lhash patch posted by an aufs user,
see Tips file in detail.

This patch is NOT tested because I am not an ubuntu user.


Index: fs/aufs/cpup.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/cpup.c,v
retrieving revision 1.60
diff -u -p -r1.60 cpup.c
--- fs/aufs/cpup.c	21 Jan 2008 04:55:55 -0000	1.60
+++ fs/aufs/cpup.c	29 Jan 2008 14:42:07 -0000
@@ -120,7 +120,8 @@ void au_cpup_attr_all(struct inode *inod
 
 /* keep the timestamps of the parent dir when cpup */
 void au_dtime_store(struct au_dtime *dt, struct dentry *dentry,
-		    struct dentry *h_dentry, struct aufs_hinode *hdir)
+		    struct dentry *h_dentry, struct aufs_hinode *hdir,
+ 		    struct vfsmount *h_mnt)
 {
 	struct inode *inode;
 
@@ -130,6 +131,7 @@ void au_dtime_store(struct au_dtime *dt,
 	dt->dt_dentry = dentry;
 	dt->dt_h_dentry = h_dentry;
 	dt->dt_hdir = hdir;
+ 	dt->dt_h_mnt = h_mnt;
 	inode = h_dentry->d_inode;
 	dt->dt_atime = inode->i_atime;
 	dt->dt_mtime = inode->i_mtime;
@@ -153,14 +155,15 @@ void au_dtime_revert(struct au_dtime *dt
 	vfsub_args_init(&vargs, &ign, au_need_dlgt(dt->dt_dentry->d_sb), 0);
 	if (unlikely(dt->dt_hdir))
 		vfsub_ign_hinode(&vargs, IN_ATTRIB, dt->dt_hdir);
-	err = vfsub_notify_change(dt->dt_h_dentry, &attr, &vargs);
+	err = vfsub_notify_change(dt->dt_h_dentry, dt->dt_h_mnt, &attr, &vargs);
 	if (unlikely(err))
 		AuWarn("restoring timestamps failed(%d). ignored\n", err);
 }
 
 /* ---------------------------------------------------------------------- */
 
-static int cpup_iattr(struct dentry *h_dst, struct dentry *h_src, int dlgt)
+static int cpup_iattr(struct dentry *h_dst, struct dentry *h_src,
+		      struct vfsmount *h_dst_mnt, int dlgt)
 {
 	int err, sbits;
 	struct iattr ia;
@@ -184,7 +187,7 @@ static int cpup_iattr(struct dentry *h_d
 	sbits = !!(ia.ia_mode & (S_ISUID | S_ISGID));
 
 	vfsub_args_init(&vargs, NULL, dlgt, /*force_unlink*/0);
-	err = vfsub_notify_change(h_dst, &ia, &vargs);
+	err = vfsub_notify_change(h_dst, h_dst_mnt, &ia, &vargs);
 	//if (LktrCond) err = -1;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
@@ -192,7 +195,7 @@ static int cpup_iattr(struct dentry *h_d
 	if (!err && sbits && au_test_nfs(h_dst->d_sb)) {
 		ia.ia_valid = ATTR_FORCE | ATTR_MODE;
 		ia.ia_mode = h_isrc->i_mode;
-		err = vfsub_notify_change(h_dst, &ia, &vargs);
+		err = vfsub_notify_change(h_dst, h_dst_mnt, &ia, &vargs);
 	}
 #endif
 	if (!err)
@@ -263,7 +266,8 @@ static int cpup_regular(struct dentry *d
 
 	/* stop updating while we copyup */
 	IMustLock(hidden[SRC].dentry->d_inode);
-	err = au_copy_file(hidden[DST].file, hidden[SRC].file, len, sb);
+	err = au_copy_file(hidden[DST].file, hidden[SRC].file, len, sb,
+			   sbr_mnt(sb, bdst));
 
  out_dst_file:
 	fput(hidden[DST].file);
@@ -289,6 +293,7 @@ static int cpup_entry(struct dentry *den
 	char *sym;
 	mm_segment_t old_fs;
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 	struct vfsub_args vargs;
 	struct aufs_hinode *hgdir;
 	const int do_dt = flags->dtime;
@@ -299,6 +304,7 @@ static int cpup_entry(struct dentry *den
 	sb = dentry->d_sb;
 	AuDebugOn(bdst >= bsrc || au_test_ro(sb, bdst, NULL));
 	/* bsrc branch can be ro/rw. */
+	h_mnt = sbr_mnt(sb, bdst);
 
 	h_src = au_h_dptr_i(dentry, bsrc);
 	AuDebugOn(!h_src);
@@ -322,7 +328,7 @@ static int cpup_entry(struct dentry *den
 			hgdir = itohi(gparent->d_inode, bdst);
 			dput(gparent);
 		}
-		au_dtime_store(&dt, parent, h_parent, hgdir);
+		au_dtime_store(&dt, parent, h_parent, hgdir, h_mnt);
 	}
 
 	mode = h_inode->i_mode;
@@ -344,7 +350,8 @@ static int cpup_entry(struct dentry *den
 			if (unlikely(err)) {
 				int rerr;
 				vfsub_args_init(&vargs, NULL, dlgt, 0);
-				rerr = vfsub_unlink(h_dir, h_dst, &vargs);
+				rerr = vfsub_unlink(h_dir, h_dst, h_mnt,
+						    &vargs);
 				if (rerr) {
 					AuIOErr("failed unlinking cpup-ed %.*s"
 						"(%d, %d)\n",
@@ -355,7 +362,7 @@ static int cpup_entry(struct dentry *den
 		}
 		break;
 	case S_IFDIR:
-		err = vfsub_mkdir(h_dir, h_dst, mode, dlgt);
+		err = vfsub_mkdir(h_dir, h_dst, h_mnt, mode, dlgt);
 		//if (LktrCond) {vfs_rmdir(h_dir, h_dst); err = -1;}
 		if (!err) {
 			/* setattr case: dir is not locked */
@@ -379,7 +386,8 @@ static int cpup_entry(struct dentry *den
 		set_fs(old_fs);
 		if (symlen > 0) {
 			sym[symlen] = 0;
-			err = vfsub_symlink(h_dir, h_dst, sym, mode, dlgt);
+			err = vfsub_symlink(h_dir, h_dst, h_mnt, sym, mode,
+					    dlgt);
 			//if (LktrCond)
 			//{vfs_unlink(h_dir, h_dst); err = -1;}
 		}
@@ -391,7 +399,7 @@ static int cpup_entry(struct dentry *den
 		/*FALLTHROUGH*/
 	case S_IFIFO:
 	case S_IFSOCK:
-		err = vfsub_mknod(h_dir, h_dst, mode,
+		err = vfsub_mknod(h_dir, h_dst, h_mnt, mode,
 				  au_h_rdev(h_inode, /*h_mnt*/NULL, h_src),
 				  dlgt);
 		//if (LktrCond) {vfs_unlink(h_dir, h_dst); err = -1;}
@@ -425,6 +433,7 @@ int au_cpup_single(struct dentry *dentry
 	struct vfsub_args vargs;
 	struct aufs_sbinfo *sbinfo;
 	struct aufs_hinode *hgdir;
+ 	struct vfsmount *h_mnt;
 
 	LKTRTrace("%.*s, i%lu, bdst %d, bsrc %d, len %Ld, dtime %u\n",
 		  AuDLNPair(dentry), dentry->d_inode->i_ino, bdst, bsrc, len,
@@ -444,6 +453,7 @@ int au_cpup_single(struct dentry *dentry
 	dir = parent->d_inode;
 
 	sbinfo = stosi(sb);
+	h_mnt = sbr_mnt(sb, bdst);
 	dlgt = au_need_dlgt(sb);
 	dst_inode = au_h_iptr_i(inode, bdst);
 	if (unlikely(dst_inode)) {
@@ -460,7 +470,8 @@ int au_cpup_single(struct dentry *dentry
 			if (IS_ERR(h_src))
 				goto out;
 			AuDebugOn(!h_src->d_inode);
-			err = vfsub_link(h_src, h_dir, h_dst, dlgt);
+			err = vfsub_link(h_src, h_mnt, h_dir, h_dst, h_mnt,
+					 dlgt);
 			dput(h_src);
 			goto out;
 		} else
@@ -477,7 +488,7 @@ int au_cpup_single(struct dentry *dentry
 	vfsub_i_lock_nested(dst_inode, AuLsc_I_CHILD2);
 
 	//todo: test dlgt
-	err = cpup_iattr(h_dst, h_src, dlgt);
+	err = cpup_iattr(h_dst, h_src, h_mnt, dlgt);
 	//if (LktrCond) err = -1;
 #if 0 // xattr
 	if (0 && !err)
@@ -506,12 +517,12 @@ int au_cpup_single(struct dentry *dentry
 		hgdir = itohi(gparent->d_inode, bdst);
 		dput(gparent);
 	}
-	au_dtime_store(&dt, parent, h_parent, hgdir);
+	au_dtime_store(&dt, parent, h_parent, hgdir, h_mnt);
 	vfsub_args_init(&vargs, NULL, dlgt, 0);
 	if (!isdir)
-		rerr = vfsub_unlink(h_dir, h_dst, &vargs);
+		rerr = vfsub_unlink(h_dir, h_dst, h_mnt, &vargs);
 	else
-		rerr = vfsub_rmdir(h_dir, h_dst, &vargs);
+		rerr = vfsub_rmdir(h_dir, h_dst, h_mnt, &vargs);
 	//rerr = -1;
 	au_dtime_revert(&dt);
 	if (rerr) {
@@ -689,6 +700,7 @@ int au_cpup_wh(struct dentry *dentry, au
 	struct au_dtime dt;
 	struct aufs_dinfo *dinfo;
 	aufs_bindex_t bstart;
+	struct vfsmount *h_mnt;
 	struct vfsub_args vargs;
 	struct aufs_hinode *hgdir;
 	struct aufs_ndx ndx = {
@@ -726,7 +738,8 @@ int au_cpup_wh(struct dentry *dentry, au
 		hgdir = itohi(gparent->d_inode, bdst);
 		dput(gparent);
 	}
-	au_dtime_store(&dt, parent, h_parent, hgdir);
+ 	h_mnt = sbr_mnt(sb, bdst);
+	au_dtime_store(&dt, parent, h_parent, hgdir, h_mnt);
 	dinfo = dtodi(dentry);
 	bstart = dinfo->di_bstart;
 	h_dentry_bdst = dinfo->di_hdentry[0 + bdst].hd_dentry;
@@ -752,7 +765,7 @@ int au_cpup_wh(struct dentry *dentry, au
 	/* dget first to force sillyrename on nfs */
 	dget(wh_dentry);
 	vfsub_args_init(&vargs, NULL, ndx.dlgt, 0);
-	err = vfsub_unlink(h_dir, wh_dentry, &vargs);
+	err = vfsub_unlink(h_dir, wh_dentry, h_mnt, &vargs);
 	//if (LktrCond) err = -1;
 	if (unlikely(err)) {
 		AuIOErr("failed remove copied-up tmp file %.*s(%d)\n",
Index: fs/aufs/cpup.h
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/cpup.h,v
retrieving revision 1.26
diff -u -p -r1.26 cpup.h
--- fs/aufs/cpup.h	21 Jan 2008 04:56:10 -0000	1.26
+++ fs/aufs/cpup.h	29 Jan 2008 14:42:07 -0000
@@ -76,10 +76,12 @@ int au_test_and_cpup_dirs(struct dentry 
 struct au_dtime {
 	struct dentry *dt_dentry, *dt_h_dentry;
 	struct aufs_hinode *dt_hdir;
+	struct vfsmount *dt_h_mnt;
 	struct timespec dt_atime, dt_mtime;
 };
 void au_dtime_store(struct au_dtime *dt, struct dentry *dentry,
-		    struct dentry *h_dentry, struct aufs_hinode *hdir);
+		    struct dentry *h_dentry, struct aufs_hinode *hdir,
+		    struct vfsmount *h_mnt);
 void au_dtime_revert(struct au_dtime *dt);
 
 #endif /* __KERNEL__ */
Index: fs/aufs/i_op.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/i_op.c,v
retrieving revision 1.53
diff -u -p -r1.53 i_op.c
--- fs/aufs/i_op.c	28 Jan 2008 05:01:42 -0000	1.53
+++ fs/aufs/i_op.c	29 Jan 2008 14:42:07 -0000
@@ -547,7 +547,7 @@ static int aufs_setattr(struct dentry *d
 			vfsub_ign_hinode(&vargs, events, itohi(dir, bcpup));
 	}
 	HiLock(bcpup);
-	err = vfsub_notify_change(h_dentry, ia, &vargs);
+	err = vfsub_notify_change(h_dentry, sbr_mnt(sb, bcpup), ia, &vargs);
 	//err = -1;
 	if (!err)
 		au_cpup_attr_changeable(inode);
Index: fs/aufs/i_op_add.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/i_op_add.c,v
retrieving revision 1.58
diff -u -p -r1.58 i_op_add.c
--- fs/aufs/i_op_add.c	28 Jan 2008 05:02:00 -0000	1.58
+++ fs/aufs/i_op_add.c	29 Jan 2008 14:42:08 -0000
@@ -27,7 +27,7 @@
  * if it failed, re-create the removed whiteout.
  */
 static int epilog(struct inode *dir, struct dentry *wh_dentry,
-		  struct dentry *dentry)
+		  struct vfsmount *h_mnt, struct dentry *dentry)
 {
 	int err, rerr;
 	aufs_bindex_t bwh;
@@ -42,7 +42,7 @@ static int epilog(struct inode *dir, str
 		h_dir = wh_dentry->d_parent->d_inode; /* dir inode is locked */
 		IMustLock(h_dir);
 		bwh = dbwh(dentry);
-		err = au_unlink_wh_dentry(h_dir, wh_dentry, dentry, dir,
+		err = au_unlink_wh_dentry(h_dir, wh_dentry, h_mnt, dentry, dir,
 					  /*dlgt*/0);
 		//err = -1;
 		if (unlikely(err))
@@ -148,7 +148,8 @@ lock_hdir_lkup_wh(struct dentry *dentry,
 #endif
 
 	if (dt)
-		au_dtime_store(dt, parent, h_parent, hgdir);
+		au_dtime_store(dt, parent, h_parent, hgdir,
+			       sbr_mnt(parent->d_sb, bcpup));
 	wh_dentry = NULL;
 	if (/* bcpup != bstart || */ bcpup != dbwh(dentry))
 		goto out; /* success */
@@ -197,6 +198,7 @@ static int add_simple(struct inode *dir,
 	struct au_dtime dt;
 	struct vfsub_args vargs;
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 	struct au_wr_dir_args wr_dir_args = {
 		.force_btgt	= -1,
 		.add_entry	= 1,
@@ -223,6 +225,7 @@ static int add_simple(struct inode *dir,
 	IMustLock(h_dir);
 	sb = dir->i_sb;
 	dlgt = au_need_dlgt(sb);
+	h_mnt = sbr_mnt(sb, dbstart(dentry));
 
 #if 1 // partial testing
 	switch (arg->type) {
@@ -232,11 +235,11 @@ static int add_simple(struct inode *dir,
 				  arg->u.c.nd, au_nfsmnt(sb, dbstart(dentry)));
 		break;
 	case Symlink:
-		err = vfsub_symlink(h_dir, h_dentry,
+		err = vfsub_symlink(h_dir, h_dentry, h_mnt,
 				    arg->u.s.symname, S_IALLUGO, dlgt);
 		break;
 	case Mknod:
-		err = vfsub_mknod(h_dir, h_dentry,
+		err = vfsub_mknod(h_dir, h_dentry, h_mnt,
 				  arg->u.m.mode, arg->u.m.dev, dlgt);
 		break;
 	default:
@@ -247,14 +250,14 @@ static int add_simple(struct inode *dir,
 #endif
 	created = !err;
 	if (!err)
-		err = epilog(dir, wh_dentry, dentry);
+		err = epilog(dir, wh_dentry, h_mnt, dentry);
 	//err = -1;
 
 	/* revert */
 	if (unlikely(created && err && h_dentry->d_inode)) {
 		int rerr;
 		vfsub_args_init(&vargs, NULL, dlgt, 0);
-		rerr = vfsub_unlink(h_dir, h_dentry, &vargs);
+		rerr = vfsub_unlink(h_dir, h_dentry, h_mnt, &vargs);
 		//rerr = -1;
 		if (rerr) {
 			AuIOErr("%.*s revert failure(%d, %d)\n",
@@ -403,6 +406,7 @@ static int cpup_or_link(struct dentry *s
 	aufs_bindex_t bstart;
 	struct super_block *sb;
 	struct au_cpup_flags cflags;
+	struct vfsmount *h_mnt;
 
 	AuTraceEnter();
 
@@ -412,8 +416,11 @@ static int cpup_or_link(struct dentry *s
 	h_inode = h_dentry->d_inode;
 	bstart = ibstart(inode);
 	h_dst_inode = NULL;
-	if (bstart <= a->bdst)
+	h_mnt = NULL;
+	if (bstart <= a->bdst) {
 		h_dst_inode = au_h_iptr_i(inode, a->bdst);
+		h_mnt = sbr_mnt(sb, a->bdst);
+	}
 
 	if (!h_dst_inode || !h_dst_inode->i_nlink) {
 		/* copyup src_dentry as the name of dentry. */
@@ -431,8 +438,8 @@ static int cpup_or_link(struct dentry *s
 		/* the inode of src_dentry already exists on a.bdst branch */
 		h_dentry = d_find_alias(h_dst_inode);
 		if (h_dentry) {
-			err = vfsub_link(h_dentry, a->h_dir,
-					 a->h_dentry, a->dlgt);
+			err = vfsub_link(h_dentry, h_mnt, a->h_dir, a->h_dentry,
+					 h_mnt, a->dlgt);
 			dput(h_dentry);
 		} else {
 			AuIOErr("no dentry found for i%lu on b%d\n",
@@ -456,6 +463,7 @@ int aufs_link(struct dentry *src_dentry,
 	struct au_dtime dt;
 	struct link_arg a;
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 	struct vfsub_args vargs;
 	struct au_wr_dir_args wr_dir_args = {
 		//.force_btgt	= -1,
@@ -499,6 +507,7 @@ int aufs_link(struct dentry *src_dentry,
 	a.bsrc = dbstart(src_dentry);
 	a.bdst = dbstart(dentry);
 	h_src_dentry = au_h_dptr(src_dentry);
+	h_mnt = sbr_mnt(sb, a.bdst);
 	if (unlikely(!AuFlag(stosi(sb), f_plink))) {
 		/*
 		 * copyup src_dentry to the branch we process,
@@ -511,8 +520,8 @@ int aufs_link(struct dentry *src_dentry,
 			err = cpup_before_link(src_dentry, dir, &a);
 		if (!err) {
 			h_src_dentry = au_h_dptr(src_dentry);
-			err = vfsub_link(h_src_dentry, a.h_dir,
-					 a.h_dentry, a.dlgt);
+			err = vfsub_link(h_src_dentry, h_mnt, a.h_dir,
+					 a.h_dentry, h_mnt, a.dlgt);
 			//err = -1;
 		}
 	} else {
@@ -521,15 +530,15 @@ int aufs_link(struct dentry *src_dentry,
 			err = cpup_or_link(src_dentry, &a);
 		else {
 			h_src_dentry = au_h_dptr(src_dentry);
-			err = vfsub_link(h_src_dentry, a.h_dir,
-					 a.h_dentry, a.dlgt);
+			err = vfsub_link(h_src_dentry, h_mnt, a.h_dir,
+					 a.h_dentry, h_mnt, a.dlgt);
 			//err = -1;
 		}
 	}
 	if (unlikely(err))
 		goto out_unlock;
 	if (wh_dentry) {
-		err = au_unlink_wh_dentry(a.h_dir, wh_dentry, dentry,
+		err = au_unlink_wh_dentry(a.h_dir, wh_dentry, h_mnt, dentry,
 					  dir, /*dlgt*/0);
 		//err = -1;
 		if (unlikely(err))
@@ -600,7 +609,7 @@ int aufs_link(struct dentry *src_dentry,
 	}
 #endif
 	vfsub_args_init(&vargs, NULL, a.dlgt, 0);
-	rerr = vfsub_unlink(a.h_dir, a.h_dentry, &vargs);
+	rerr = vfsub_unlink(a.h_dir, a.h_dentry, h_mnt, &vargs);
 	//rerr = -1;
 	if (!rerr)
 		goto out_dt;
@@ -635,6 +644,7 @@ int aufs_mkdir(struct inode *dir, struct
 	struct au_dtime dt;
 	aufs_bindex_t bindex;
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 	struct vfsub_args vargs;
 	struct au_wr_dir_args wr_dir_args = {
 		.force_btgt	= -1,
@@ -664,8 +674,9 @@ int aufs_mkdir(struct inode *dir, struct
 	h_dir = h_parent->d_inode;
 	IMustLock(h_dir);
 	dlgt = au_need_dlgt(sb);
+	h_mnt = sbr_mnt(sb, bindex);
 
-	err = vfsub_mkdir(h_dir, h_dentry, mode, dlgt);
+	err = vfsub_mkdir(h_dir, h_dentry, h_mnt, mode, dlgt);
 	//err = -1;
 	if (unlikely(err))
 		goto out_unlock;
@@ -685,7 +696,7 @@ int aufs_mkdir(struct inode *dir, struct
 		diropq = 1;
 	}
 
-	err = epilog(dir, wh_dentry, dentry);
+	err = epilog(dir, wh_dentry, h_mnt, dentry);
 	//err = -1;
 	if (!err) {
 		dir->i_nlink++;
@@ -709,7 +720,7 @@ int aufs_mkdir(struct inode *dir, struct
  out_dir:
 	LKTRLabel(revert dir);
 	vfsub_args_init(&vargs, NULL, dlgt, 0);
-	rerr = vfsub_rmdir(h_dir, h_dentry, &vargs);
+	rerr = vfsub_rmdir(h_dir, h_dentry, h_mnt, &vargs);
 	//rerr = -1;
 	if (rerr) {
 		AuIOErr("%.*s reverting dir failed(%d, %d)\n",
Index: fs/aufs/i_op_del.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/i_op_del.c,v
retrieving revision 1.57
diff -u -p -r1.57 i_op_del.c
--- fs/aufs/i_op_del.c	28 Jan 2008 05:02:03 -0000	1.57
+++ fs/aufs/i_op_del.c	29 Jan 2008 14:42:08 -0000
@@ -153,7 +153,8 @@ lock_hdir_create_wh(struct dentry *dentr
 	revalidate h_positive
 #endif
 
-	au_dtime_store(dt, parent, h_parent, hgdir);
+	au_dtime_store(dt, parent, h_parent, hgdir,
+		       sbr_mnt(dentry->d_sb, bcpup));
 	wh_dentry = NULL;
 	if (!need_wh)
 		goto out; /* success, no need to create whiteout */
@@ -243,16 +244,17 @@ struct revert_flags {
 	unsigned int	dlgt:1;
 };
 
-static int do_revert(int err, struct dentry *wh_dentry, struct dentry *dentry,
-		     aufs_bindex_t bwh, struct au_dtime *dt,
-		     struct revert_flags *flags)
+static int do_revert(int err, struct dentry *wh_dentry, struct vfsmount *h_mnt,
+		     struct dentry *dentry, aufs_bindex_t bwh,
+		     struct au_dtime *dt, struct revert_flags *flags)
 {
 	int rerr;
 	struct inode *dir;
 
 	dir = wh_dentry->d_parent->d_inode; /* dir inode is locked */
 	IMustLock(dir);
-	rerr = au_unlink_wh_dentry(dir, wh_dentry, dentry, dir, !!flags->dlgt);
+	rerr = au_unlink_wh_dentry(dir, wh_dentry, h_mnt, dentry, dir,
+				   !!flags->dlgt);
 	//rerr = -1;
 	if (!rerr) {
 		set_dbwh(dentry, bwh);
@@ -275,6 +277,7 @@ int aufs_unlink(struct inode *dir, struc
 	struct au_dtime dt;
 	aufs_bindex_t bwh, bindex, bstart;
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 	struct vfsub_args vargs;
 
 	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
@@ -301,12 +304,13 @@ int aufs_unlink(struct inode *dir, struc
 	dlgt = au_need_dlgt(sb);
 	h_dentry = au_h_dptr(dentry);
 	dget(h_dentry);
+	h_mnt = sbr_mnt(sb, dbstart(dentry));
 
 	if (bindex == bstart) {
 		vfsub_args_init(&vargs, NULL, dlgt, 0);
 		h_dir = h_dentry->d_parent->d_inode; /* dir inode is locked */
 		IMustLock(h_dir);
-		err = vfsub_unlink(h_dir, h_dentry, &vargs);
+		err = vfsub_unlink(h_dir, h_dentry, h_mnt, &vargs);
 		//err = -1;
 	} else {
 		/* dir inode is locked */
@@ -339,7 +343,8 @@ int aufs_unlink(struct inode *dir, struc
 		struct revert_flags rev_flags = {
 			.dlgt	= dlgt
 		};
-		rerr = do_revert(err, wh_dentry, dentry, bwh, &dt, &rev_flags);
+		rerr = do_revert(err, wh_dentry, h_mnt, dentry, bwh, &dt,
+				 &rev_flags);
 		if (rerr)
 			err = rerr;
 	}
@@ -365,6 +370,7 @@ int aufs_rmdir(struct inode *dir, struct
 	struct rmdir_whtmp_args *args;
 	struct aufs_nhash *whlist;
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 
 	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
 	IMustLock(dir);
@@ -403,6 +409,7 @@ int aufs_rmdir(struct inode *dir, struct
 
 	h_dentry = au_h_dptr(dentry);
 	dget(h_dentry);
+	h_mnt = sbr_mnt(dentry->d_sb, dbstart(dentry));
 
 	rmdir_later = 0;
 	if (bindex == bstart) {
@@ -449,7 +456,8 @@ int aufs_rmdir(struct inode *dir, struct
 		struct revert_flags rev_flags = {
 			.dlgt	= au_need_dlgt(sb)
 		};
-		rerr = do_revert(err, wh_dentry, dentry, bwh, &dt, &rev_flags);
+		rerr = do_revert(err, wh_dentry, h_mnt, dentry, bwh, &dt,
+				 &rev_flags);
 		if (rerr)
 			err = rerr;
 	}
Index: fs/aufs/i_op_ren.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/i_op_ren.c,v
retrieving revision 1.63
diff -u -p -r1.63 i_op_ren.c
--- fs/aufs/i_op_ren.c	28 Jan 2008 05:02:03 -0000	1.63
+++ fs/aufs/i_op_ren.c	29 Jan 2008 14:42:08 -0000
@@ -26,6 +26,7 @@ struct rename_args {
 	struct aufs_nhash whlist;
 	aufs_bindex_t btgt, bstart[2];
 	struct super_block *sb;
+	struct vfsmount *h_mnt;
 
 	unsigned int isdir:1;
 	unsigned int issamedir:1;
@@ -146,8 +147,9 @@ static int do_rename(struct inode *src_d
 		if (unlikely(a->udba && a->isdir))
 			vfsub_ign_hinode(&vargs, IN_MOVE_SELF,
 					 itohi(src_dentry->d_inode, a->btgt));
-		err = vfsub_rename(h_dir[SRC], au_h_dptr(src_dentry),
-				   h_dir[DST], a->h_dentry[DST], &vargs);
+		err = vfsub_rename(h_dir[SRC], au_h_dptr(src_dentry), a->h_mnt,
+				   h_dir[DST], a->h_dentry[DST], a->h_mnt,
+				   &vargs);
 		//err = -1;
 	} else {
 		bycpup = 1;
@@ -185,7 +187,7 @@ static int do_rename(struct inode *src_d
 
 	/* remove whiteout for dentry */
 	if (wh_dentry[DST]) {
-		err = au_unlink_wh_dentry(h_dir[DST], wh_dentry[DST],
+		err = au_unlink_wh_dentry(h_dir[DST], wh_dentry[DST], a->h_mnt,
 					  dentry, dir, /*dlgt*/0);
 		//err = -1;
 		if (unlikely(err))
@@ -254,8 +256,8 @@ static int do_rename(struct inode *src_d
 			vfsub_ign_hinode(&vargs, IN_MOVE_SELF,
 					 itohi(src_dentry->d_inode, a->btgt));
 		rerr = vfsub_rename
-			(h_dir[DST], au_h_dptr_i(src_dentry, a->btgt),
-			 h_dir[SRC], d, &vargs);
+			(h_dir[DST], au_h_dptr_i(src_dentry, a->btgt), a->h_mnt,
+			 h_dir[SRC], d, a->h_mnt, &vargs);
 		//rerr = -1;
 		d_drop(d);
 		dput(d);
@@ -264,7 +266,8 @@ static int do_rename(struct inode *src_d
 			RevertFailure("rename %.*s", AuDLNPair(src_dentry));
 	} else {
 		vfsub_args_init(&vargs, NULL, a->dlgt, 0);
-		rerr = vfsub_unlink(h_dir[DST], a->h_dentry[DST], &vargs);
+		rerr = vfsub_unlink(h_dir[DST], a->h_dentry[DST], a->h_mnt,
+				    &vargs);
 		//rerr = -1;
 		set_h_dptr(src_dentry, a->btgt, NULL);
 		set_dbstart(src_dentry, a->bstart[SRC]);
@@ -294,7 +297,8 @@ static int do_rename(struct inode *src_d
 		if (unlikely(0 && a->udba && a->isdir))
 			vfsub_ign_hinode(&vargs, IN_MOVE_SELF,
 					 itohi(dentry->d_inode, a->btgt));
-		rerr = vfsub_rename(h_dir[DST], h_dst, h_dir[DST], d, &vargs);
+		rerr = vfsub_rename(h_dir[DST], h_dst, a->h_mnt, h_dir[DST], d,
+				    a->h_mnt, &vargs);
 		//rerr = -1;
 		d_drop(d);
 		dput(d);
@@ -311,7 +315,7 @@ static int do_rename(struct inode *src_d
  out_whsrc:
 	if (wh_dentry[SRC]) {
 		LKTRLabel(here);
-		rerr = au_unlink_wh_dentry(h_dir[SRC], wh_dentry[SRC],
+		rerr = au_unlink_wh_dentry(h_dir[SRC], wh_dentry[SRC], a->h_mnt,
 					   src_dentry, src_dir, /*dlgt*/0);
 		//rerr = -1;
 		if (rerr)
@@ -572,6 +576,7 @@ int aufs_rename(struct inode *src_dir, s
 	hgdir[SRC] = NULL;
 	hgdir[DST] = NULL;
 	au_hgdirs(hgdir, &p->a);
+	p->a.h_mnt = sbr_mnt(p->a.sb, p->a.btgt);
 	p->a.h_parent[SRC] = au_h_dptr_i(p->a.parent[SRC], p->a.btgt);
 	p->a.h_parent[DST] = au_h_dptr_i(p->a.parent[DST], p->a.btgt);
 	dirs[0] = src_dir;
@@ -602,20 +607,22 @@ int aufs_rename(struct inode *src_dir, s
 
 	/* store timestamps to be revertible */
 	au_dtime_store(p->dt[PARENT] + SRC, p->a.parent[SRC],
-		       p->a.h_parent[SRC], hgdir[SRC]);
+		       p->a.h_parent[SRC], hgdir[SRC], p->a.h_mnt);
 	if (!p->a.issamedir)
 		au_dtime_store(p->dt[PARENT] + DST, p->a.parent[DST],
-			       p->a.h_parent[DST], hgdir[DST]);
+			       p->a.h_parent[DST], hgdir[DST], p->a.h_mnt);
 	do_dt_dstdir = 0;
 	if (p->a.isdir) {
 		au_dtime_store
 			(p->dt[CHILD] + SRC, src_dentry, p->a.h_dentry[SRC],
-			 itohi(p->a.parent[SRC]->d_inode, p->a.btgt));
+			 itohi(p->a.parent[SRC]->d_inode, p->a.btgt),
+			 p->a.h_mnt);
 		if (p->a.h_dentry[DST]->d_inode) {
 			do_dt_dstdir = 1;
 			au_dtime_store
 				(p->dt[CHILD] + DST, dentry, p->a.h_dentry[DST],
-				 itohi(p->a.parent[DST]->d_inode, p->a.btgt));
+				 itohi(p->a.parent[DST]->d_inode, p->a.btgt),
+				 p->a.h_mnt);
 		}
 	}
 
Index: fs/aufs/misc.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/misc.c,v
retrieving revision 1.47
diff -u -p -r1.47 misc.c
--- fs/aufs/misc.c	12 Nov 2007 01:40:06 -0000	1.47
+++ fs/aufs/misc.c	29 Jan 2008 14:42:08 -0000
@@ -154,7 +154,7 @@ int au_h_create(struct inode *h_dir, str
 /* ---------------------------------------------------------------------- */
 
 int au_copy_file(struct file *dst, struct file *src, loff_t len,
-		 struct super_block *sb)
+		 struct super_block *sb, struct vfsmount *dst_mnt)
 {
 	int err, all_zero;
 	unsigned long blksize;
@@ -265,10 +265,9 @@ int au_copy_file(struct file *dst, struc
 		} while (err == -EAGAIN || err == -EINTR);
 		if (err == 1) {
 			ia->ia_size = dst->f_pos;
-			ia->ia_valid = ATTR_SIZE | ATTR_FILE;
-			ia->ia_file = dst;
+			ia->ia_valid = ATTR_SIZE;
 			vfsub_i_lock_nested(h_i, AuLsc_I_CHILD2);
-			err = vfsub_notify_change(h_d, ia, &vargs);
+			err = vfsub_notify_change(h_d, dst_mnt, ia, &vargs);
 			vfsub_i_unlock(h_i);
 		}
 	}
Index: fs/aufs/misc.h
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/misc.h,v
retrieving revision 1.39
diff -u -p -r1.39 misc.h
--- fs/aufs/misc.h	21 Jan 2008 04:57:48 -0000	1.39
+++ fs/aufs/misc.h	29 Jan 2008 14:42:08 -0000
@@ -201,7 +201,7 @@ int au_h_create(struct inode *h_dir, str
 		int dlgt, struct nameidata *nd, struct vfsmount *nfsmnt);
 
 int au_copy_file(struct file *dst, struct file *src, loff_t len,
-		 struct super_block *sb);
+		 struct super_block *sb, struct vfsmount *dst_mnt);
 int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,
 	       struct inode *inode);
 int au_test_perm(struct inode *h_inode, int mask, int dlgt);
Index: fs/aufs/plink.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/plink.c,v
retrieving revision 1.16
diff -u -p -r1.16 plink.c
--- fs/aufs/plink.c	29 Oct 2007 04:41:10 -0000	1.16
+++ fs/aufs/plink.c	29 Jan 2008 14:42:08 -0000
@@ -119,8 +119,8 @@ struct dentry *au_lkup_plink(struct supe
 }
 
 static int do_whplink(char *tgt, int len, struct dentry *h_parent,
-		      struct dentry *h_dentry, struct vfsmount *nfsmnt,
-		      struct super_block *sb)
+		      struct dentry *h_dentry, struct vfsmount *h_mnt,
+		      struct vfsmount *nfsmnt, struct super_block *sb)
 {
 	int err;
 	struct dentry *h_tgt;
@@ -142,9 +142,9 @@ static int do_whplink(char *tgt, int len
 	vfsub_args_init(&vargs, NULL, ndx.dlgt, 0);
 	h_dir = h_parent->d_inode;
 	if (unlikely(h_tgt->d_inode && h_tgt->d_inode != h_dentry->d_inode))
-		err = vfsub_unlink(h_dir, h_tgt, &vargs);
+		err = vfsub_unlink(h_dir, h_tgt, h_mnt, &vargs);
 	if (!err && !h_tgt->d_inode) {
-		err = vfsub_link(h_dentry, h_dir, h_tgt, ndx.dlgt);
+		err = vfsub_link(h_dentry, h_mnt, h_dir, h_tgt, h_mnt, ndx.dlgt);
 		//inode->i_nlink++;
 	}
 	dput(h_tgt);
@@ -160,6 +160,7 @@ struct do_whplink_args {
 	int len;
 	struct dentry *h_parent;
 	struct dentry *h_dentry;
+	struct vfsmount *h_mnt;
 	struct vfsmount *nfsmnt;
 	struct super_block *sb;
 };
@@ -168,7 +169,7 @@ static void call_do_whplink(void *args)
 {
 	struct do_whplink_args *a = args;
 	*a->errp = do_whplink(a->tgt, a->len, a->h_parent, a->h_dentry,
-			      a->nfsmnt, a->sb);
+			      a->h_mnt, a->nfsmnt, a->sb);
 }
 
 static int whplink(struct dentry *h_dentry, struct inode *inode,
@@ -198,6 +199,7 @@ static int whplink(struct dentry *h_dent
 			.len		= len,
 			.h_parent	= h_parent,
 			.h_dentry	= h_dentry,
+			.h_mnt		= br->br_mnt,
 			.nfsmnt		= au_do_nfsmnt(br->br_mnt),
 			.sb		= sb
 		};
@@ -206,7 +208,7 @@ static int whplink(struct dentry *h_dent
 			err = wkq_err;
 	} else
 		err = do_whplink(tgtname, len, h_parent, h_dentry,
-				 au_do_nfsmnt(br->br_mnt), sb);
+				 br->br_mnt, au_do_nfsmnt(br->br_mnt), sb);
 	vfsub_i_unlock(h_dir);
 
 	AuTraceErr(err);
Index: fs/aufs/vfsub.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/vfsub.c,v
retrieving revision 1.26
diff -u -p -r1.26 vfsub.c
--- fs/aufs/vfsub.c	28 Jan 2008 05:01:42 -0000	1.26
+++ fs/aufs/vfsub.c	29 Jan 2008 14:42:08 -0000
@@ -369,6 +369,7 @@ struct symlink_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	const char *symname;
 	int mode;
 };
@@ -376,20 +377,22 @@ struct symlink_args {
 static void call_symlink(void *args)
 {
 	struct symlink_args *a = args;
-	*a->errp = do_vfsub_symlink(a->dir, a->dentry, a->symname, a->mode);
+	*a->errp = do_vfsub_symlink(a->dir, a->dentry, a->mnt, a->symname,
+				    a->mode);
 }
 
-int vfsub_symlink(struct inode *dir, struct dentry *dentry, const char *symname,
-		  int mode, int dlgt)
+int vfsub_symlink(struct inode *dir, struct dentry *dentry,
+		  struct vfsmount *mnt, const char *symname, int mode, int dlgt)
 {
 	if (!dlgt)
-		return do_vfsub_symlink(dir, dentry, symname, mode);
+		return do_vfsub_symlink(dir, dentry, mnt, symname, mode);
 	else {
 		int err, wkq_err;
 		struct symlink_args args = {
 			.errp		= &err,
 			.dir		= dir,
 			.dentry		= dentry,
+			.mnt		= mnt,
 			.symname	= symname,
 			.mode		= mode
 		};
@@ -404,6 +407,7 @@ struct mknod_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	int mode;
 	dev_t dev;
 };
@@ -411,20 +415,21 @@ struct mknod_args {
 static void call_mknod(void *args)
 {
 	struct mknod_args *a = args;
-	*a->errp = do_vfsub_mknod(a->dir, a->dentry, a->mode, a->dev);
+	*a->errp = do_vfsub_mknod(a->dir, a->dentry, a->mnt, a->mode, a->dev);
 }
 
-int vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev,
-		int dlgt)
+int vfsub_mknod(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
+		int mode, dev_t dev, int dlgt)
 {
 	if (!dlgt)
-		return do_vfsub_mknod(dir, dentry, mode, dev);
+		return do_vfsub_mknod(dir, dentry, mnt, mode, dev);
 	else {
 		int err, wkq_err;
 		struct mknod_args args = {
 			.errp	= &err,
 			.dir	= dir,
 			.dentry	= dentry,
+			.mnt	= mnt,
 			.mode	= mode,
 			.dev	= dev
 		};
@@ -439,25 +444,28 @@ struct mkdir_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	int mode;
 };
 
 static void call_mkdir(void *args)
 {
 	struct mkdir_args *a = args;
-	*a->errp = do_vfsub_mkdir(a->dir, a->dentry, a->mode);
+	*a->errp = do_vfsub_mkdir(a->dir, a->dentry, a->mnt, a->mode);
 }
 
-int vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode, int dlgt)
+int vfsub_mkdir(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
+		int mode, int dlgt)
 {
 	if (!dlgt)
-		return do_vfsub_mkdir(dir, dentry, mode);
+		return do_vfsub_mkdir(dir, dentry, mnt, mode);
 	else {
 		int err, wkq_err;
 		struct mkdir_args args = {
 			.errp	= &err,
 			.dir	= dir,
 			.dentry	= dentry,
+			.mnt	= mnt,
 			.mode	= mode
 		};
 		wkq_err = au_wkq_wait(call_mkdir, &args, /*dlgt*/1);
@@ -473,6 +481,7 @@ struct link_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *src_dentry, *dentry;
+	struct vfsmount *src_mnt, *mnt;
 };
 
 static void call_link(void *args)
@@ -481,18 +490,21 @@ static void call_link(void *args)
 	*a->errp = do_vfsub_link(a->src_dentry, a->dir, a->dentry);
 }
 
-int vfsub_link(struct dentry *src_dentry, struct inode *dir,
-	       struct dentry *dentry, int dlgt)
+int vfsub_link(struct dentry *src_dentry, struct vfsmount *src_mnt,
+	       struct inode *dir, struct dentry *dentry,
+	       struct vfsmount *mnt, int dlgt)
 {
 	if (!dlgt)
-		return do_vfsub_link(src_dentry, dir, dentry);
+		return do_vfsub_link(src_dentry, src_mnt, dir, dentry, mnt);
 	else {
 		int err, wkq_err;
 		struct link_args args = {
 			.errp		= &err,
 			.src_dentry	= src_dentry,
+			.src_mnt	= src_mnt,
 			.dir		= dir,
-			.dentry		= dentry
+			.dentry		= dentry,
+			.mnt		= mnt
 		};
 		wkq_err = au_wkq_wait(call_link, &args, /*dlgt*/1);
 		if (unlikely(wkq_err))
@@ -505,6 +517,7 @@ struct rename_args {
 	int *errp;
 	struct inode *src_dir, *dir;
 	struct dentry *src_dentry, *dentry;
+	struct vfsmount *src_mnt, *mnt;
 	struct vfsub_args *vargs;
 };
 
@@ -512,21 +525,23 @@ static void call_rename(void *args)
 {
 	struct rename_args *a = args;
 	vfsub_ignore(a->vargs);
-	*a->errp = do_vfsub_rename(a->src_dir, a->src_dentry, a->dir,
-				   a->dentry);
+	*a->errp = do_vfsub_rename(a->src_dir, a->src_dentry, a->src_mnt,
+				   a->dir, a->dentry, a->mnt);
 	if (unlikely(*a->errp))
 		vfsub_unignore(a->vargs);
 }
 
 int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
-		 struct inode *dir, struct dentry *dentry,
+		 struct vfsmount *src_mnt,
+		 struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
 		 struct vfsub_args *vargs)
 {
 	int err;
 
 	if (!vargs->dlgt) {
 		vfsub_ignore(vargs);
-		err = do_vfsub_rename(src_dir, src_dentry, dir, dentry);
+		err = do_vfsub_rename(src_dir, src_dentry, src_mnt, dir, dentry,
+				      mnt);
 		if (unlikely(err))
 			vfsub_unignore(vargs);
 	} else {
@@ -535,8 +550,10 @@ int vfsub_rename(struct inode *src_dir, 
 			.errp		= &err,
 			.src_dir	= src_dir,
 			.src_dentry	= src_dentry,
+			.src_mnt	= src_mnt,
 			.dir		= dir,
 			.dentry		= dentry,
+			.mnt		= mnt,
 			.vargs		= vargs
 		};
 		wkq_err = au_wkq_wait(call_rename, &args, /*dlgt*/1);
@@ -550,6 +567,7 @@ struct rmdir_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	struct vfsub_args *vargs;
 };
 
@@ -557,19 +575,19 @@ static void call_rmdir(void *args)
 {
 	struct rmdir_args *a = args;
 	vfsub_ignore(a->vargs);
-	*a->errp = do_vfsub_rmdir(a->dir, a->dentry);
+	*a->errp = do_vfsub_rmdir(a->dir, a->dentry, a->mnt);
 	if (unlikely(*a->errp))
 		vfsub_unignore(a->vargs);
 }
 
-int vfsub_rmdir(struct inode *dir, struct dentry *dentry,
+int vfsub_rmdir(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
 		struct vfsub_args *vargs)
 {
 	int err;
 
 	if (!vargs->dlgt) {
 		vfsub_ignore(vargs);
-		err = do_vfsub_rmdir(dir, dentry);
+		err = do_vfsub_rmdir(dir, dentry, mnt);
 		if (unlikely(err))
 			vfsub_unignore(vargs);
 	} else {
@@ -578,6 +596,7 @@ int vfsub_rmdir(struct inode *dir, struc
 			.errp	= &err,
 			.dir	= dir,
 			.dentry	= dentry,
+			.mnt	= mnt,
 			.vargs	= vargs
 		};
 		wkq_err = au_wkq_wait(call_rmdir, &args, /*dlgt*/1);
@@ -975,6 +994,7 @@ struct au_vfsub_mkdir_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	int mode;
 	int dlgt;
 };
@@ -982,11 +1002,11 @@ struct au_vfsub_mkdir_args {
 static void au_call_vfsub_mkdir(void *args)
 {
 	struct au_vfsub_mkdir_args *a = args;
-	*a->errp = vfsub_mkdir(a->dir, a->dentry, a->mode, a->dlgt);
+	*a->errp = vfsub_mkdir(a->dir, a->dentry, a->mnt, a->mode, a->dlgt);
 }
 
-int vfsub_sio_mkdir(struct inode *dir, struct dentry *dentry, int mode,
-		    int dlgt)
+int vfsub_sio_mkdir(struct inode *dir, struct dentry *dentry,
+		    struct vfsmount *mnt, int mode, int dlgt)
 {
 	int err, do_sio, wkq_err;
 
@@ -994,12 +1014,13 @@ int vfsub_sio_mkdir(struct inode *dir, s
 
 	do_sio = au_test_perm(dir, MAY_EXEC | MAY_WRITE, dlgt);
 	if (!do_sio)
-		err = vfsub_mkdir(dir, dentry, mode, dlgt);
+		err = vfsub_mkdir(dir, dentry, mnt, mode, dlgt);
 	else {
 		struct au_vfsub_mkdir_args args = {
 			.errp	= &err,
 			.dir	= dir,
 			.dentry	= dentry,
+			.mnt	= mnt,
 			.mode	= mode,
 			.dlgt	= dlgt
 		};
@@ -1016,16 +1037,18 @@ struct au_vfsub_rmdir_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	struct vfsub_args *vargs;
 };
 
 static void au_call_vfsub_rmdir(void *args)
 {
 	struct au_vfsub_rmdir_args *a = args;
-	*a->errp = vfsub_rmdir(a->dir, a->dentry, a->vargs);
+	*a->errp = vfsub_rmdir(a->dir, a->dentry, a->mnt, a->vargs);
 }
 
-int vfsub_sio_rmdir(struct inode *dir, struct dentry *dentry, int dlgt)
+int vfsub_sio_rmdir(struct inode *dir, struct dentry *dentry,
+		    struct vfsmount *mnt, int dlgt)
 {
 	int err, do_sio, wkq_err;
 	struct vfsub_args vargs;
@@ -1035,12 +1058,13 @@ int vfsub_sio_rmdir(struct inode *dir, s
 	vfsub_args_init(&vargs, /*ign*/NULL, dlgt, /*force_unlink*/0);
 	do_sio = au_test_perm(dir, MAY_EXEC | MAY_WRITE, dlgt);
 	if (!do_sio)
-		err = vfsub_rmdir(dir, dentry, &vargs);
+		err = vfsub_rmdir(dir, dentry, mnt, &vargs);
 	else {
 		struct au_vfsub_rmdir_args args = {
 			.errp		= &err,
 			.dir		= dir,
 			.dentry		= dentry,
+			.mnt		= mnt,
 			.vargs		= &vargs
 		};
 		wkq_err = au_wkq_wait(au_call_vfsub_rmdir, &args, /*dlgt*/0);
@@ -1057,6 +1081,7 @@ int vfsub_sio_rmdir(struct inode *dir, s
 struct notify_change_args {
 	int *errp;
 	struct dentry *h_dentry;
+	struct vfsmount *h_mnt;
 	struct iattr *ia;
 	struct vfsub_args *vargs;
 };
@@ -1075,7 +1100,7 @@ static void call_notify_change(void *arg
 	if (!IS_IMMUTABLE(h_inode) && !IS_APPEND(h_inode)) {
 		vfsub_ignore(a->vargs);
 		lockdep_off();
-		*a->errp = notify_change(a->h_dentry, a->ia);
+		*a->errp = notify_change(a->h_dentry, a->h_mnt, a->ia);
 		lockdep_on();
 		if (!*a->errp)
 			au_update_fuse_h_inode(NULL, a->h_dentry); /*ignore*/
@@ -1085,13 +1110,14 @@ static void call_notify_change(void *arg
 	AuTraceErr(*a->errp);
 }
 
-int vfsub_notify_change(struct dentry *dentry, struct iattr *ia,
-			struct vfsub_args *vargs)
+int vfsub_notify_change(struct dentry *dentry, struct vfsmount *mnt,
+			struct iattr *ia, struct vfsub_args *vargs)
 {
 	int err;
 	struct notify_change_args args = {
 		.errp		= &err,
 		.h_dentry	= dentry,
+		.h_mnt		= mnt,
 		.ia		= ia,
 		.vargs		= vargs
 	};
@@ -1119,6 +1145,7 @@ struct unlink_args {
 	int *errp;
 	struct inode *dir;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	struct vfsub_args *vargs;
 };
 
@@ -1149,7 +1176,7 @@ static void call_unlink(void *args)
 			err = -1;
 	}
 #else
-	*a->errp = do_vfsub_unlink(a->dir, a->dentry);
+	*a->errp = do_vfsub_unlink(a->dir, a->dentry, a->mnt);
 #endif
 
 	if (!stop_sillyrename)
@@ -1164,7 +1191,7 @@ static void call_unlink(void *args)
  * @dir: must be locked.
  * @dentry: target dentry.
  */
-int vfsub_unlink(struct inode *dir, struct dentry *dentry,
+int vfsub_unlink(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
 		 struct vfsub_args *vargs)
 {
 	int err;
@@ -1172,6 +1199,7 @@ int vfsub_unlink(struct inode *dir, stru
 		.errp	= &err,
 		.dir	= dir,
 		.dentry	= dentry,
+		.mnt	= mnt,
 		.vargs	= vargs
 	};
 
Index: fs/aufs/vfsub.h
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/vfsub.h,v
retrieving revision 1.28
diff -u -p -r1.28 vfsub.h
--- fs/aufs/vfsub.h	28 Jan 2008 05:01:42 -0000	1.28
+++ fs/aufs/vfsub.h	29 Jan 2008 14:42:08 -0000
@@ -368,7 +368,7 @@ int do_vfsub_create(struct inode *dir, s
 
 static inline
 int do_vfsub_symlink(struct inode *dir, struct dentry *dentry,
-		     const char *symname, int mode)
+		     struct vfsmount *mnt, const char *symname, int mode)
 {
 	int err;
 
@@ -376,7 +376,7 @@ int do_vfsub_symlink(struct inode *dir, 
 		  dir->i_ino, AuDLNPair(dentry), symname, mode);
 	IMustLock(dir);
 
-	err = vfs_symlink(dir, dentry, symname, mode);
+	err = vfs_symlink(dir, dentry, mnt, symname, mode);
 	if (!err) {
 		/* dir inode is locked */
 		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
@@ -386,15 +386,15 @@ int do_vfsub_symlink(struct inode *dir, 
 }
 
 static inline
-int do_vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode,
-		   dev_t dev)
+int do_vfsub_mknod(struct inode *dir, struct dentry *dentry,
+		   struct vfsmount *mnt, int mode, dev_t dev)
 {
 	int err;
 
 	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
 	IMustLock(dir);
 
-	err = vfs_mknod(dir, dentry, mode, dev);
+	err = vfs_mknod(dir, dentry, mnt, mode, dev);
 	if (!err) {
 		/* dir inode is locked */
 		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
@@ -404,8 +404,9 @@ int do_vfsub_mknod(struct inode *dir, st
 }
 
 static inline
-int do_vfsub_link(struct dentry *src_dentry, struct inode *dir,
-		  struct dentry *dentry)
+int do_vfsub_link(struct dentry *src_dentry, struct vfsmount *src_mnt,
+		  struct inode *dir, struct dentry *dentry,
+		  struct vfsmount *mnt)
 {
 	int err;
 
@@ -414,7 +415,7 @@ int do_vfsub_link(struct dentry *src_den
 	IMustLock(dir);
 
 	lockdep_off();
-	err = vfs_link(src_dentry, dir, dentry);
+	err = vfs_link(src_dentry, src_mnt, dir, dentry, mnt);
 	lockdep_on();
 	if (!err) {
 		LKTRTrace("src_i %p, dst_i %p\n",
@@ -430,7 +431,9 @@ int do_vfsub_link(struct dentry *src_den
 
 static inline
 int do_vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
-		    struct inode *dir, struct dentry *dentry)
+		    struct vfsmount *src_mnt,
+		    struct inode *dir, struct dentry *dentry,
+		    struct vfsmount *mnt)
 {
 	int err;
 
@@ -441,7 +444,7 @@ int do_vfsub_rename(struct inode *src_di
 	IMustLock(src_dir);
 
 	lockdep_off();
-	err = vfs_rename(src_dir, src_dentry, dir, dentry);
+	err = vfs_rename(src_dir, src_dentry, src_mnt, dir, dentry, mnt);
 	lockdep_on();
 	if (!err) {
 		/* dir inode is locked */
@@ -453,14 +456,15 @@ int do_vfsub_rename(struct inode *src_di
 }
 
 static inline
-int do_vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+int do_vfsub_mkdir(struct inode *dir, struct dentry *dentry,
+		   struct vfsmount *mnt, int mode)
 {
 	int err;
 
 	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
 	IMustLock(dir);
 
-	err = vfs_mkdir(dir, dentry, mode);
+	err = vfs_mkdir(dir, dentry, mnt, mode);
 	if (!err) {
 		/* dir inode is locked */
 		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
@@ -469,7 +473,8 @@ int do_vfsub_mkdir(struct inode *dir, st
 	return err;
 }
 
-static inline int do_vfsub_rmdir(struct inode *dir, struct dentry *dentry)
+static inline int do_vfsub_rmdir(struct inode *dir, struct dentry *dentry,
+				 struct vfsmount *mnt)
 {
 	int err;
 
@@ -477,7 +482,7 @@ static inline int do_vfsub_rmdir(struct 
 	IMustLock(dir);
 
 	lockdep_off();
-	err = vfs_rmdir(dir, dentry);
+	err = vfs_rmdir(dir, dentry, mnt);
 	lockdep_on();
 	/* dir inode is locked */
 	if (!err)
@@ -485,7 +490,8 @@ static inline int do_vfsub_rmdir(struct 
 	return err;
 }
 
-static inline int do_vfsub_unlink(struct inode *dir, struct dentry *dentry)
+static inline int do_vfsub_unlink(struct inode *dir, struct dentry *dentry,
+				  struct vfsmount *mnt)
 {
 	int err;
 
@@ -494,7 +500,7 @@ static inline int do_vfsub_unlink(struct
 
 	/* vfs_unlink() locks inode */
 	lockdep_off();
-	err = vfs_unlink(dir, dentry);
+	err = vfs_unlink(dir, dentry, mnt);
 	lockdep_on();
 	/* dir inode is locked */
 	if (!err)
@@ -721,54 +727,57 @@ int vfsub_create(struct inode *dir, stru
 }
 
 static inline
-int vfsub_symlink(struct inode *dir, struct dentry *dentry, const char *symname,
-		  int mode, int dlgt)
+int vfsub_symlink(struct inode *dir, struct dentry *dentry,
+		  struct vfsmount *mnt, const char *symname, int mode, int dlgt)
 {
-	return do_vfsub_symlink(dir, dentry, symname, mode);
+	return do_vfsub_symlink(dir, dentry, mnt, symname, mode);
 }
 
 static inline
-int vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev,
-		int dlgt)
+int vfsub_mknod(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
+		int mode, dev_t dev, int dlgt)
 {
-	return do_vfsub_mknod(dir, dentry, mode, dev);
+	return do_vfsub_mknod(dir, dentry, mnt, mode, dev);
 }
 
 static inline
-int vfsub_link(struct dentry *src_dentry, struct inode *dir,
-	       struct dentry *dentry, int dlgt)
+int vfsub_link(struct dentry *src_dentry, struct vfsmount *src_mnt,
+	       struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
+	       int dlgt)
 {
-	return do_vfsub_link(src_dentry, dir, dentry);
+	return do_vfsub_link(src_dentry, src_mnt, dir, dentry, mnt);
 }
 
 static inline
 int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
-		 struct inode *dir, struct dentry *dentry,
+		 struct vfsmount *src_mnt,
+		 struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
 		 struct vfsub_args *vargs)
 {
 	int err;
 
 	vfsub_ignore(vargs);
-	err = do_vfsub_rename(src_dir, src_dentry, dir, dentry);
+	err = do_vfsub_rename(src_dir, src_dentry, src_mnt, dir, dentry, mnt);
 	if (unlikely(err))
 		vfsub_unignore(vargs);
 	return err;
 }
 
 static inline
-int vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode, int dlgt)
+int vfsub_mkdir(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
+		int mode, int dlgt)
 {
-	return do_vfsub_mkdir(dir, dentry, mode);
+	return do_vfsub_mkdir(dir, dentry, mnt, mode);
 }
 
 static inline
-int vfsub_rmdir(struct inode *dir, struct dentry *dentry,
+int vfsub_rmdir(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
 		struct vfsub_args *vargs)
 {
 	int err;
 
 	vfsub_ignore(vargs);
-	err = do_vfsub_rmdir(dir, dentry);
+	err = do_vfsub_rmdir(dir, dentry, mnt);
 	if (unlikely(err))
 		vfsub_unignore(vargs);
 	return err;
@@ -851,15 +860,16 @@ static inline int vfsub_getattr(struct v
 
 /* ---------------------------------------------------------------------- */
 
-int vfsub_sio_mkdir(struct inode *dir, struct dentry *dentry, int mode,
-		    int dlgt);
-int vfsub_sio_rmdir(struct inode *dir, struct dentry *dentry, int dlgt);
+int vfsub_sio_mkdir(struct inode *dir, struct dentry *dentry,
+		    struct vfsmount *mnt, int mode, int dlgt);
+int vfsub_sio_rmdir(struct inode *dir, struct dentry *dentry,
+		    struct vfsmount *mnt, int dlgt);
 
 /* ---------------------------------------------------------------------- */
 
-int vfsub_notify_change(struct dentry *dentry, struct iattr *ia,
-			struct vfsub_args *vargs);
-int vfsub_unlink(struct inode *dir, struct dentry *dentry,
+int vfsub_notify_change(struct dentry *dentry, struct vfsmount *mnt,
+			struct iattr *ia, struct vfsub_args *vargs);
+int vfsub_unlink(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
 		 struct vfsub_args *vargs);
 int vfsub_statfs(void *arg, struct kstatfs *buf, int dlgt);
 
Index: fs/aufs/wbr_policy.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/wbr_policy.c,v
retrieving revision 1.5
diff -u -p -r1.5 wbr_policy.c
--- fs/aufs/wbr_policy.c	26 Nov 2007 01:34:50 -0000	1.5
+++ fs/aufs/wbr_policy.c	29 Jan 2008 14:42:08 -0000
@@ -21,7 +21,8 @@
 #include <linux/statfs.h>
 #include "aufs.h"
 
-static int au_cpdown_attr(struct dentry *h_dst, struct dentry *h_src, int dlgt)
+static int au_cpdown_attr(struct dentry *h_dst, struct dentry *h_src,
+			  struct vfsmount *h_dst_mnt, int dlgt)
 {
 	int err, sbits;
 	struct iattr ia;
@@ -41,14 +42,14 @@ static int au_cpdown_attr(struct dentry 
 	sbits = !!(ia.ia_mode & (S_ISUID | S_ISGID));
 
 	vfsub_args_init(&vargs, NULL, dlgt, /*force_unlink*/0);
-	err = vfsub_notify_change(h_dst, &ia, &vargs);
+	err = vfsub_notify_change(h_dst, h_dst_mnt, &ia, &vargs);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 	/* is this nfs only? */
 	if (!err && sbits && au_test_nfs(h_dst->d_sb)) {
 		ia.ia_valid = ATTR_FORCE | ATTR_MODE;
 		ia.ia_mode = h_isrc->i_mode;
-		err = vfsub_notify_change(h_dst, &ia, &vargs);
+		err = vfsub_notify_change(h_dst, h_dst_mnt, &ia, &vargs);
 	}
 #endif
 	if (!err)
@@ -71,6 +72,7 @@ static int au_cpdown_dir(struct dentry *
 	aufs_bindex_t bend, bopq;
 	struct dentry *h_dentry, *opq_dentry, *wh_dentry;
 	struct inode *h_dir, *h_inode, *inode;
+	struct vfsmount *h_mnt;
 
 	LKTRTrace("%.*s, b%d\n", AuDLNPair(dentry), bdst);
 	AuDebugOn(dbstart(dentry) <= bdst
@@ -84,9 +86,10 @@ static int au_cpdown_dir(struct dentry *
 	err = au_lkup_neg(dentry, bdst);
 	if (unlikely(err < 0))
 		goto out;
+	h_mnt = sbr_mnt(dentry->d_sb, bdst);
 	h_dentry = au_h_dptr_i(dentry, bdst);
 	dlgt = au_need_dlgt(dentry->d_sb);
-	err = vfsub_sio_mkdir(h_dir, h_dentry, 0755, dlgt);
+	err = vfsub_sio_mkdir(h_dir, h_dentry, h_mnt, 0755, dlgt);
 	if (unlikely(err))
 		goto out_put;
 
@@ -112,7 +115,7 @@ static int au_cpdown_dir(struct dentry *
 		diropq = 1;
 	}
 
-	err = au_cpdown_attr(h_dentry, au_h_dptr(dentry), dlgt);
+	err = au_cpdown_attr(h_dentry, au_h_dptr(dentry), h_mnt, dlgt);
 	vfsub_i_unlock(h_inode);
 	if (unlikely(err))
 		goto out_opq;
@@ -125,8 +128,8 @@ static int au_cpdown_dir(struct dentry *
 			goto out_opq;
 		err = 0;
 		if (wh_dentry->d_inode)
-			err = au_unlink_wh_dentry(h_dir, wh_dentry, dentry,
-						  NULL, dlgt);
+			err = au_unlink_wh_dentry(h_dir, wh_dentry, h_mnt,
+						  dentry, NULL, dlgt);
 		dput(wh_dentry);
 		if (unlikely(err))
 			goto out_opq;
@@ -153,7 +156,7 @@ static int au_cpdown_dir(struct dentry *
 	}
  out_dir:
 	if (made_dir) {
-		rerr = vfsub_sio_rmdir(h_dir, h_dentry, dlgt);
+		rerr = vfsub_sio_rmdir(h_dir, h_dentry, h_mnt, dlgt);
 		if (unlikely(rerr)) {
 			AuIOErr("failed removing %.*s b%d (%d)\n",
 				AuDLNPair(dentry), bdst, rerr);
Index: fs/aufs/whout.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/whout.c,v
retrieving revision 1.30
diff -u -p -r1.30 whout.c
--- fs/aufs/whout.c	28 Jan 2008 05:01:42 -0000	1.30
+++ fs/aufs/whout.c	29 Jan 2008 14:42:08 -0000
@@ -219,6 +219,7 @@ int rename_whtmp(struct inode *dir, stru
 	struct dentry *h_dentry, *h_parent, *tmp_dentry;
 	struct super_block *sb;
 	struct aufs_hin_ignore ign;
+	struct vfsmount *h_mnt;
 	struct vfsub_args vargs;
 	struct aufs_ndx ndx = {
 		.nd	= NULL,
@@ -240,13 +241,15 @@ int rename_whtmp(struct inode *dir, stru
 	err = PTR_ERR(tmp_dentry);
 	if (!IS_ERR(tmp_dentry)) {
 		/* under the same dir, no need to lock_rename() */
+		h_mnt = sbr_mnt(sb, bindex);
 		vfsub_args_init(&vargs, &ign, ndx.dlgt, 0);
 		AuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));
 		if (unlikely(au_flag_test_udba_inotify(sb)
 			     && !noself))
 			vfsub_ign_hinode(&vargs, IN_MOVE_SELF,
 					 itohi(dentry->d_inode, bindex));
-		err = vfsub_rename(h_dir, h_dentry, h_dir, tmp_dentry, &vargs);
+		err = vfsub_rename(h_dir, h_dentry, h_mnt, h_dir, tmp_dentry,
+				   h_mnt, &vargs);
 		//if (LktrCond) err = -1; //unavailable
 		AuTraceErr(err);
 		dput(tmp_dentry);
@@ -259,7 +262,7 @@ int rename_whtmp(struct inode *dir, stru
 /* ---------------------------------------------------------------------- */
 
 static int do_unlink_wh(struct inode *h_dir, struct dentry *wh_dentry,
-			struct inode *dir, int dlgt)
+			struct vfsmount *h_mnt, struct inode *dir, int dlgt)
 {
 	struct vfsub_args vargs;
 
@@ -274,11 +277,12 @@ static int do_unlink_wh(struct inode *h_
 	vfsub_args_init(&vargs, NULL, dlgt,
 			(h_dir->i_mode & S_ISVTX)
 			&& wh_dentry->d_inode->i_uid != current->fsuid);
-	return vfsub_unlink(h_dir, wh_dentry, &vargs);
+	return vfsub_unlink(h_dir, wh_dentry, h_mnt, &vargs);
 }
 
 int au_unlink_wh_dentry(struct inode *h_dir, struct dentry *wh_dentry,
-			struct dentry *dentry, struct inode *dir, int dlgt)
+			struct vfsmount *h_mnt, struct dentry *dentry,
+			struct inode *dir, int dlgt)
 {
 	int err;
 
@@ -288,7 +292,7 @@ int au_unlink_wh_dentry(struct inode *h_
 		  || !wh_dentry->d_inode
 		  || !S_ISREG(wh_dentry->d_inode->i_mode));
 
-	err = do_unlink_wh(h_dir, wh_dentry, dir, dlgt);
+	err = do_unlink_wh(h_dir, wh_dentry, h_mnt, dir, dlgt);
 	//if (LktrCond) err = -1; // unavailable
 	if (!err && dentry)
 		set_dbwh(dentry, -1);
@@ -298,7 +302,8 @@ int au_unlink_wh_dentry(struct inode *h_
 }
 
 static int unlink_wh_name(struct dentry *h_parent, struct qstr *wh,
-			  struct inode *dir, struct aufs_ndx *ndx)
+			  struct vfsmount *h_mnt, struct inode *dir,
+			  struct aufs_ndx *ndx)
 {
 	int err;
 	struct inode *h_dir;
@@ -314,7 +319,8 @@ static int unlink_wh_name(struct dentry 
 		err = 0;
 		if (h_dentry->d_inode
 		    && S_ISREG(h_dentry->d_inode->i_mode))
-			err = do_unlink_wh(h_dir, h_dentry, dir, ndx->dlgt);
+			err = do_unlink_wh(h_dir, h_dentry, h_mnt, dir,
+					   ndx->dlgt);
 		dput(h_dentry);
 	} else
 		err = PTR_ERR(h_dentry);
@@ -325,7 +331,8 @@ static int unlink_wh_name(struct dentry 
 
 /* ---------------------------------------------------------------------- */
 
-static void clean_wh(struct inode *h_dir, struct dentry *wh)
+static void clean_wh(struct inode *h_dir, struct dentry *wh,
+		     struct vfsmount *h_mnt)
 {
 	int err;
 	struct vfsub_args vargs;
@@ -334,14 +341,15 @@ static void clean_wh(struct inode *h_dir
 
 	if (wh->d_inode) {
 		vfsub_args_init(&vargs, NULL, 0, 0);
-		err = vfsub_unlink(h_dir, wh, &vargs);
+		err = vfsub_unlink(h_dir, wh, h_mnt, &vargs);
 		if (unlikely(err))
 			AuWarn("failed unlink %.*s (%d), ignored.\n",
 			       AuDLNPair(wh), err);
 	}
 }
 
-static void clean_plink(struct inode *h_dir, struct dentry *plink)
+static void clean_plink(struct inode *h_dir, struct dentry *plink,
+			struct vfsmount *h_mnt)
 {
 	int err;
 	struct vfsub_args vargs;
@@ -350,7 +358,7 @@ static void clean_plink(struct inode *h_
 
 	if (plink->d_inode) {
 		vfsub_args_init(&vargs, NULL, 0, 0);
-		err = vfsub_rmdir(h_dir, plink, &vargs);
+		err = vfsub_rmdir(h_dir, plink, h_mnt, &vargs);
 		if (unlikely(err))
 			AuWarn("failed rmdir %.*s (%d), ignored.\n",
 			       AuDLNPair(plink), err);
@@ -364,7 +372,8 @@ static int test_linkable(struct inode *h
 	return -ENOSYS;
 }
 
-static int plink_dir(struct inode *h_dir, struct dentry *plink)
+static int plink_dir(struct inode *h_dir, struct dentry *plink,
+		     struct vfsmount *h_mnt)
 {
 	int err;
 
@@ -373,7 +382,7 @@ static int plink_dir(struct inode *h_dir
 		int mode = S_IRWXU;
 		if (unlikely(au_test_nfs(plink->d_sb)))
 			mode |= S_IXUGO;
-		err = vfsub_mkdir(h_dir, plink, mode, /*dlgt*/0);
+		err = vfsub_mkdir(h_dir, plink, h_mnt, mode, /*dlgt*/0);
 	} else if (S_ISDIR(plink->d_inode->i_mode))
 		err = 0;
 	else
@@ -439,23 +448,23 @@ int init_wh(struct dentry *h_root, struc
 	case AuBr_RO:
 	case AuBr_RRWH:
 	case AuBr_ROWH:
-		clean_wh(h_dir, wh);
-		clean_plink(h_dir, plink);
+		clean_wh(h_dir, wh, br->br_mnt);
+		clean_plink(h_dir, plink, br->br_mnt);
 		break;
 
 	case AuBr_RWNoLinkWH:
-		clean_wh(h_dir, wh);
+		clean_wh(h_dir, wh, br->br_mnt);
 		if (do_plink) {
 			err = test_linkable(h_dir);
 			if (unlikely(err))
 				goto out_nolink;
 
-			err = plink_dir(h_dir, plink);
+			err = plink_dir(h_dir, plink, br->br_mnt);
 			if (unlikely(err))
 				goto out_err;
 			br->br_plink = dget(plink);
 		} else
-			clean_plink(h_dir, plink);
+			clean_plink(h_dir, plink, br->br_mnt);
 		break;
 
 	case AuBr_RW:
@@ -484,12 +493,12 @@ int init_wh(struct dentry *h_root, struc
 			goto out_err;
 
 		if (do_plink) {
-			err = plink_dir(h_dir, plink);
+			err = plink_dir(h_dir, plink, br->br_mnt);
 			if (unlikely(err))
 				goto out_err;
 			br->br_plink = dget(plink);
 		} else
-			clean_plink(h_dir, plink);
+			clean_plink(h_dir, plink, br->br_mnt);
 		br->br_wh = dget(wh);
 		break;
 
@@ -550,7 +559,7 @@ static void reinit_br_wh(void *arg)
 	revalidate h_wh
 #endif
 	br_wh_write_lock(a->br);
-	err = vfsub_unlink(h_dir, a->br->br_wh, &vargs);
+	err = vfsub_unlink(h_dir, a->br->br_wh, a->br->br_mnt, &vargs);
 	//if (LktrCond) err = -1;
 	dput(a->br->br_wh);
 	a->br->br_wh = NULL;
@@ -624,7 +633,8 @@ static int link_or_create_wh(struct dent
 	br = stobr(sb, bindex);
 	br_wh_read_lock(br);
 	if (br->br_wh) {
-		err = vfsub_link(br->br_wh, h_dir, wh, dlgt);
+		err = vfsub_link(br->br_wh, br->br_mnt, h_dir, wh, br->br_mnt,
+				 dlgt);
 		if (!err || err != -EMLINK)
 			goto out;
 
@@ -688,8 +698,8 @@ static struct dentry *do_diropq(struct d
 	} else {
 		AuDebugOn(/* !S_ISDIR(dentry->d_inode->i_mode)
 			   * ||  */!opq_dentry->d_inode);
-		err = do_unlink_wh(h_dir, opq_dentry, dentry->d_inode,
-				   ndx.dlgt);
+		err = do_unlink_wh(h_dir, opq_dentry, sbr_mnt(sb, bindex),
+				   dentry->d_inode, ndx.dlgt);
 		//if (LktrCond) err = -1;
 		if (!err)
 			set_dbdiropq(dentry, -1);
@@ -820,6 +830,7 @@ static int del_wh_children(struct aufs_n
 	struct aufs_wh *tpos;
 	struct hlist_node *pos;
 	struct aufs_destr *str;
+	struct vfsmount *h_mnt;
 
 	LKTRTrace("%.*s\n", AuDLNPair(h_parent));
 	h_dir = h_parent->d_inode;
@@ -837,6 +848,7 @@ static int del_wh_children(struct aufs_n
 
 	/* already checked by au_test_perm(). */
 	err = 0;
+	h_mnt = sbr_mnt(inode->i_sb, bindex);
 	for (i = 0; !err && i < AuSize_NHASH; i++) {
 		head = whlist->heads + i;
 		hlist_for_each_entry(tpos, pos, head, wh_hash) {
@@ -846,8 +858,8 @@ static int del_wh_children(struct aufs_n
 			if (str->len + AUFS_WH_PFX_LEN <= PATH_MAX) {
 				memcpy(p, str->name, str->len);
 				wh_name.len = AUFS_WH_PFX_LEN + str->len;
-				err = unlink_wh_name(h_parent, &wh_name, inode,
-						     ndx);
+				err = unlink_wh_name(h_parent, &wh_name, h_mnt,
+						     inode, ndx);
 				//if (LktrCond) err = -1;
 				if (!err)
 					continue;
@@ -949,7 +961,7 @@ int rmdir_whtmp(struct dentry *h_dentry,
 			     && !noself))
 			vfsub_ign_hinode(&vargs, IN_DELETE_SELF,
 					 itohi(inode, bindex));
-		err = vfsub_rmdir(h_dir, h_dentry, &vargs);
+		err = vfsub_rmdir(h_dir, h_dentry, sbr_mnt(sb, bindex), &vargs);
 		//d_drop(h_dentry);
 		//if (LktrCond) err = -1;
 	}
Index: fs/aufs/whout.h
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/whout.h,v
retrieving revision 1.13
diff -u -p -r1.13 whout.h
--- fs/aufs/whout.h	1 Oct 2007 04:48:51 -0000	1.13
+++ fs/aufs/whout.h	29 Jan 2008 14:42:08 -0000
@@ -39,7 +39,8 @@ struct dentry *lkup_whtmp(struct dentry 
 int rename_whtmp(struct inode *dir, struct dentry *dentry, aufs_bindex_t bindex,
 		 int noself);
 int au_unlink_wh_dentry(struct inode *h_dir, struct dentry *wh_dentry,
-			struct dentry *dentry, struct inode *dir, int dlgt);
+			struct vfsmount *h_mnt, struct dentry *dentry,
+			struct inode *dir, int dlgt);
 
 struct aufs_branch;
 int init_wh(struct dentry *h_parent, struct aufs_branch *br,
Index: fs/aufs/xino.c
===================================================================
RCS file: /cvsroot/aufs/aufs/fs/aufs/xino.c,v
retrieving revision 1.47
diff -u -p -r1.47 xino.c
--- fs/aufs/xino.c	10 Dec 2007 01:19:54 -0000	1.47
+++ fs/aufs/xino.c	29 Jan 2008 14:42:08 -0000
@@ -520,7 +520,7 @@ struct file *xino_create(struct super_bl
 	h_dir = h_parent->d_inode;
 	vfsub_args_init(&vargs, NULL, 0, 0);
 	vfsub_i_lock_nested(h_dir, AuLsc_I_PARENT);
-	err = vfsub_unlink(h_dir, file->f_dentry, &vargs);
+	err = vfsub_unlink(h_dir, file->f_dentry, file->f_vfsmnt, &vargs);
 	vfsub_i_unlock(h_dir);
 	dput(h_parent);
 	if (unlikely(err)) {
@@ -611,7 +611,7 @@ static struct file *xino_create2(struct 
 		goto out_dput;
 	}
 	vfsub_args_init(&vargs, NULL, 0, 0);
-	err = vfsub_unlink(dir, dentry, &vargs);
+	err = vfsub_unlink(dir, dentry, file->f_vfsmnt, &vargs);
 	//if (LktrCond) err = -1;
 	if (unlikely(err)) {
 		AuErr("%.*s unlink err %d\n", AuLNPair(name), err);
@@ -620,7 +620,8 @@ static struct file *xino_create2(struct 
 
 	if (unlikely(copy_src)) {
 		inode = copy_src->f_dentry->d_inode;
-		err = au_copy_file(file, copy_src, i_size_read(inode), sb);
+		err = au_copy_file(file, copy_src, i_size_read(inode), sb,
+				   file->f_vfsmnt);
 		if (unlikely(err)) {
 			AuErr("%.*s copy err %d\n", AuLNPair(name), err);
 			goto out_fput;

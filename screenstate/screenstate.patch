diff -ur linux-2.6.24/drivers/cpufreq/Kconfig linux-2.6.24-b/drivers/cpufreq/Kconfig
--- linux-2.6.24/drivers/cpufreq/Kconfig	2010-04-25 23:00:26.000000000 -0400
+++ linux-2.6.24-b/drivers/cpufreq/Kconfig	2010-04-29 22:01:14.000000000 -0400
@@ -87,6 +87,15 @@
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
+config CPU_FREQ_DEFAULT_GOV_SCREENSTATE
+        bool "screenstate"
+        select CPU_FREQ_GOV_SCREENSTATE
+        help
+          Use the CPUFreq governor 'screenstate' as default. This will
+	  scale the CPU frequency down when the LCD is off then scale
+	  back to max speed when LCD is powered on.  This also will not
+	  allow to set the CPU frequency manually.
+
 config CPU_FREQ_DEFAULT_GOV_ONDEMAND
 	bool "ondemand"
 	select CPU_FREQ_GOV_ONDEMAND
@@ -149,6 +158,16 @@
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_GOV_SCREENSTATE
+        tristate "'screenstate' governor for frequency scaling"
+        help
+          Enable this cpufreq governor to scale when LCD is on/off.
+
+          To compile this driver as a module, choose M here: the
+          module will be called cpufreq_screenstate.
+
+          If in doubt, say Y.
+
 config CPU_FREQ_GOV_ONDEMAND
 	tristate "'ondemand' cpufreq policy governor"
 	select CPU_FREQ_TABLE
diff -ur linux-2.6.24/drivers/cpufreq/Makefile linux-2.6.24-b/drivers/cpufreq/Makefile
--- linux-2.6.24/drivers/cpufreq/Makefile	2008-01-24 17:58:37.000000000 -0500
+++ linux-2.6.24-b/drivers/cpufreq/Makefile	2010-04-29 21:59:11.000000000 -0400
@@ -9,6 +9,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_SCREENSTATE)	+= cpufreq_screenstate.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff -ur linux-2.6.24-a/drivers/video/omap/lcd_panel.c linux-2.6.24-b/drivers/video/omap/lcd_panel.c
--- linux-2.6.24-a/drivers/video/omap/lcd_panel.c       2010-04-29 23:57:09.000000000 -0400
+++ linux-2.6.24-b/drivers/video/omap/lcd_panel.c       2010-05-01 00:48:31.000000000 -0400
@@ -31,6 +31,11 @@
 
 #include "lcd.h"
 
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+void cpufreq_gov_screenstate_lcdon(void);
+void cpufreq_gov_screenstate_lcdoff(void);
+#endif
+
 #define MOD_NAME               "LCD: "
 
 #undef MODDEBUG
@@ -52,7 +57,6 @@
 #define DISPLAY_BACKLIGHT_STATE_ON     1
 #define DISPLAY_BACKLIGHT_STATE_OFF    0
 
-
 struct lcd_params {
        struct display_device *disp_dev;
        struct platform_device *pdev;
@@ -128,6 +132,11 @@
                                                DISPLAY_BACKLIGHT_STATE_ON);
                }
                params->panel_state = DISPLAY_DEVICE_STATE_ON;
+
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+               cpufreq_gov_screenstate_lcdon();
+#endif
+
        } else {
                if (params->panel_state == DISPLAY_DEVICE_STATE_OFF) {
                        DPRINTK(" %s:  Panel already off, returning...\n",
@@ -156,11 +165,16 @@
                                                DISPLAY_CONTROLLER_STATE_OFF);
                }
                params->panel_state = DISPLAY_DEVICE_STATE_OFF;
+
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+               cpufreq_gov_screenstate_lcdoff();
+#endif
        }
 
 unlock:
         mutex_unlock(&params->ops_lock);
        release_console_sem();
+
 }
 
 static unsigned int panel_get_state(struct lcd_params *params)
@@ -178,7 +192,17 @@
        if (params->bl_dev && params->bl_ops &&
            params->bl_ops->bl_set_brightness) {
                params->bl_ops->bl_set_brightness(params->bl_dev, brightness);
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+               // Scale down when on touchstone
+                       if (brightness > 1) {
+                               cpufreq_gov_screenstate_lcdon();
+                       }
+                       else {
+                               cpufreq_gov_screenstate_lcdoff();
+                       }
+#endif
        }
+
        mutex_unlock(&params->ops_lock);
 }
 
diff -ur linux-2.6.24/include/linux/cpufreq.h linux-2.6.24-b/include/linux/cpufreq.h
--- linux-2.6.24/include/linux/cpufreq.h	2010-04-25 23:00:27.000000000 -0400
+++ linux-2.6.24-b/include/linux/cpufreq.h	2010-04-29 22:27:58.000000000 -0400
@@ -309,6 +309,9 @@
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_userspace)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_SCREENSTATE)
+extern struct cpufreq_governor cpufreq_gov_screenstate;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_screenstate)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND)
 extern struct cpufreq_governor cpufreq_gov_ondemand;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_ondemand)
diff -ur linux-2.6.24-a/drivers/usb/gadget/gadget_event.c linux-2.6.24-b/drivers/usb/gadget/gadget_event.c
--- linux-2.6.24-a/drivers/usb/gadget/gadget_event.c    2010-04-29 23:57:09.000000000 -0400
+++ linux-2.6.24-b/drivers/usb/gadget/gadget_event.c    2010-05-17 19:04:55.000000000 -0400
@@ -282,6 +282,13 @@
 }
 EXPORT_SYMBOL(gadget_event_power_state_changed);
 
+#ifdef CONFIG_CPU_FREQ_GOV_SCREENSTATE
+int ss_usb_charger(void) {
+       return the_state.current_mA;
+}
+EXPORT_SYMBOL(ss_usb_charger);
+#endif
+
 static int __init init(void)
 {
        int ret = 0;
diff -BurN linux-2.6.24/drivers/cpufreq/cpufreq_screenstate.c linux-2.6.24-b/drivers/cpufreq/cpufreq_screenstate.c
--- linux-2.6.24/drivers/cpufreq/cpufreq_screenstate.c  1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.24-b/drivers/cpufreq/cpufreq_screenstate.c        2010-04-29 22:49:38.000000000 -0400
@@ -0,0 +1,163 @@
+/*
+ *  linux/drivers/cpufreq/cpufreq_screenstate.c
+ *
+ *  Modfied by:        marco@unixpsycho.com 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/mutex.h>
+#include <asm/uaccess.h>
+
+static unsigned int    cpu_max_freq;
+static unsigned int    cpu_min_freq;
+static unsigned int    cpu_cur_freq;
+static unsigned int    cpu_is_managed;
+static unsigned int    is_charging;
+
+int ss_usb_charger(void);
+
+static DEFINE_MUTEX    (screenstate_mutex);
+
+static int screenstate_cpufreq_notifier(struct notifier_block *nb, unsigned long val, void *data) {
+        struct cpufreq_freqs *freq = data;
+
+       if (!cpu_is_managed)  return 0;
+       cpu_cur_freq = freq->new;
+        return 0;
+}
+
+static struct notifier_block screenstate_cpufreq_notifier_block = {
+        .notifier_call  = screenstate_cpufreq_notifier
+};
+
+static ssize_t show_charging(struct cpufreq_policy *policy, char *buf) {
+       return sprintf (buf, "%u\n", is_charging);
+}
+
+static ssize_t store_charging(struct cpufreq_policy *policy, const char *buf, size_t count) {
+       unsigned int chsts = 0;
+
+       if(sscanf (buf, "%u", &chsts) != 1) return -EINVAL;
+
+       if((chsts != 0) && (chsts != 1))  return -EINVAL;
+       else {
+               __cpufreq_driver_target(policy, cpu_min_freq, CPUFREQ_RELATION_L);
+               is_charging = chsts;
+       }
+
+       return count;
+}
+
+static struct freq_attr freq_attr_is_charging = {
+        .attr = { .name = "on_ts_charger", .mode = 0644 },
+        .show = show_charging,
+        .store = store_charging,
+};
+
+static int cpufreq_governor_screenstate(struct cpufreq_policy *policy,
+                                  unsigned int event) {
+       unsigned int cpu = policy->cpu;
+
+       switch (event) {
+               case CPUFREQ_GOV_START:
+                       if (!cpu_online(cpu)) return -EINVAL;
+                       mutex_lock(&screenstate_mutex);
+                       if(sysfs_create_file(&policy->kobj, &freq_attr_is_charging.attr))
+                               goto start_out;
+                       cpufreq_register_notifier(
+                               &screenstate_cpufreq_notifier_block,
+                               CPUFREQ_TRANSITION_NOTIFIER);
+                       cpu_is_managed = 1;
+                       is_charging = 0;
+                       cpu_min_freq = 500000;
+                       cpu_max_freq = policy->max;
+                       cpu_cur_freq = policy->cur;
+start_out:
+                       mutex_unlock(&screenstate_mutex);
+                       break;
+               case CPUFREQ_GOV_STOP:
+                       mutex_lock(&screenstate_mutex);
+                       cpufreq_unregister_notifier(
+                               &screenstate_cpufreq_notifier_block,
+                               CPUFREQ_TRANSITION_NOTIFIER);
+                       cpu_is_managed = 0;
+                       is_charging = 0;
+                       cpu_min_freq = 0;
+                       cpu_max_freq = 0;
+                       sysfs_remove_file(&policy->kobj, &freq_attr_is_charging.attr);
+                       mutex_unlock(&screenstate_mutex);
+                       break;
+               case CPUFREQ_GOV_LIMITS:
+                       mutex_lock(&screenstate_mutex);
+                       if((is_charging) || (ss_usb_charger() == 1000))
+                               __cpufreq_driver_target(policy, cpu_min_freq, CPUFREQ_RELATION_L);
+                       cpu_min_freq = 500000;
+                       cpu_max_freq = policy->max;
+                       if(cpu_cur_freq != policy->cur) {
+                               printk("CPUfreq: %u != %u\n",cpu_cur_freq, policy->cur);
+                       }
+                       cpu_cur_freq = policy->cur;
+                       mutex_unlock(&screenstate_mutex);
+                       break;
+               }
+               return 0;
+}
+
+struct cpufreq_governor cpufreq_gov_screenstate = {
+       .name           = "screenstate",
+       .governor       = cpufreq_governor_screenstate,
+       .owner          = THIS_MODULE,
+};
+
+static int __init cpufreq_gov_screenstate_init(void) {
+       return cpufreq_register_governor(&cpufreq_gov_screenstate);
+}
+
+static void __exit cpufreq_gov_screenstate_exit(void) {
+       cpufreq_unregister_governor(&cpufreq_gov_screenstate);
+}
+
+void cpufreq_gov_screenstate_lcdoff(void) {
+       struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+       if(cpu_is_managed) {
+               cpufreq_driver_target(policy, cpu_min_freq, CPUFREQ_RELATION_L);
+       }
+}
+EXPORT_SYMBOL(cpufreq_gov_screenstate_lcdoff);
+
+void cpufreq_gov_screenstate_lcdon(void) {
+       struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+        if(cpu_is_managed) {
+                if((!is_charging) && (ss_usb_charger() != 1000)) cpufreq_driver_target(policy, cpu_max_freq, CPUFREQ_RELATION_H);
+               else cpufreq_driver_target(policy, cpu_min_freq, CPUFREQ_RELATION_L);
+        }
+}
+EXPORT_SYMBOL(cpufreq_gov_screenstate_lcdon);
+
+EXPORT_SYMBOL(cpufreq_gov_screenstate);
+
+MODULE_AUTHOR ("marco@unixpsycho.com");
+MODULE_DESCRIPTION ("CPUfreq policy governor 'screenstate'");
+MODULE_LICENSE ("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_SCREENSTATE
+fs_initcall(cpufreq_gov_screenstate_init);
+#else
+module_init(cpufreq_gov_screenstate_init);
+#endif
+module_exit(cpufreq_gov_screenstate_exit);

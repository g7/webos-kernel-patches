--- linux-2.6.24/arch/arm/mach-msm/acpuclock.c.orig
+++ linux-2.6.24/arch/arm/mach-msm/acpuclock.c
@@ -202,6 +202,7 @@
 	{ 0, 400000, ACPU_PLL_2, 2, 2, 133333, 2, 122880, 5 },
 	{ 1, 480000, ACPU_PLL_0, 4, 1, 160000, 2, 122880, 6 },
 	{ 1, 600000, ACPU_PLL_2, 2, 1, 200000, 2, 122880, 7 },
+	{ 1, 748800, ACPU_PLL_2, 2, 0, 187200, 3, 122880, 7 },	
 	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 };
 
@@ -378,7 +393,7 @@
 
 /* Set proper dividers for the given clock speed. */
 static void acpuclk_set_div(const struct clkctl_acpu_speed *hunt_s) {
-	uint32_t reg_clkctl, reg_clksel, clk_div, src_sel;
+	uint32_t reg_clkctl, reg_clksel, clk_div, src_sel, a11_div;
 
 	reg_clksel = readl(A11S_CLK_SEL_ADDR);
 
@@ -387,6 +402,14 @@
 	/* CLK_SEL_SRC1NO */
 	src_sel = reg_clksel & 1;
 
+        /* Overclock override */
+        a11_div = hunt_s->a11clk_src_div;
+        if (hunt_s->a11clk_khz > 600000) {
+		a11_div=0;
+		writel(hunt_s->a11clk_khz/19200, PLLn_L_VAL(2));
+		udelay(50);
+        }
+
 	/*
 	 * If the new clock divider is higher than the previous, then
 	 * program the divider before switching the clock
@@ -400,7 +423,19 @@
 	/* Program clock source and divider */
 	reg_clkctl = readl(A11S_CLK_CNTL_ADDR);
 	reg_clkctl &= ~(0xFF << (8 * src_sel));
+
+        // Only kick in if over 600Mhz
+        if (hunt_s->a11clk_khz > 600000) {
+        	reg_clkctl |= a11_div;
+        }
+
 	reg_clkctl |= hunt_s->a11clk_src_sel << (4 + 8 * src_sel);
+
+        // Only kick in if over 600Mhz
+        if (hunt_s->a11clk_khz > 600000) {
+        	reg_clkctl |= a11_div;
+        }
+
 	reg_clkctl |= hunt_s->a11clk_src_div << (0 + 8 * src_sel);
 	writel(reg_clkctl, A11S_CLK_CNTL_ADDR);
 
